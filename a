#!/usr/bin/env bash
#
# hbc - hinto's bash compiler
#
# Copyright (c) 2022 hinto-janaiyo <https://github.com/hinto-janaiyo>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

#git <hbc/e35ca7a>
#nix <1658843067>
#hbc <e35ca7a>
#lib <stdlib/ask.sh/1eaba1f>
#lib <stdlib/debug.sh/1eaba1f>
#lib <stdlib/log.sh/1eaba1f>
#lib <stdlib/readonly.sh/1eaba1f>
#lib <stdlib/trace.sh/1eaba1f>

#-------------------------------------------------------------------------------- BEGIN SAFETY
POSIXLY_CORRECT= || exit 90
	# bash builtins
\unset -f alias bg bind break builtin caller cd command compgen complete compopt continue declare dirs disown echo enable eval exec exit export false fc fg getopts hash help history jobs kill let local logout mapfile popd printf pushd pwd read readarray readonly return set shift shopt source suspend test times trap true type typeset ulimit umask unalias unset wait || exit 91
	# gnu core-utils
\unset -f arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp csplit cut date dd df dir dircolors dirname du echo env expand expr factor false fmt fold groups head hostid hostname id install join kill link ln logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm rmdir runcon seq shred shuf sleep sort split stat stdbuf stty sum tac tail tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink uptime users vdir wc who whoami yes || exit 92
\unalias -a || exit 93
unset POSIXLY_CORRECT || exit 94
unset -f . : [ || exit 95
set -eo pipefail || exit 96

#-------------------------------------------------------------------------------- BEGIN LIB
trap 'printf "%s\n" "@@@@@@ LIB PANIC @@@@@@" "[line] ${LINENO}" "[file] $0" "[code] $?";set +eo pipefail;trap - ERR;while :;do read;done;exit 112' ERR || exit 112
ask::yes() {
	local STD_ASK_REPONSE || return 44
	read -r STD_ASK_REPONSE
	case $STD_ASK_REPONSE in
		""|y|Y|yes|Yes|YES) return 0 ;;
		*) return 2 ;;
	esac
}
ask::no() {
	local STD_ASK_RESPONSE || return 44
	read -r STD_ASK_RESPONSE
	case $STD_ASK_RESPONSE in
		y|Y|yes|Yes|YES) return 2 ;;
		*) return 0 ;;
	esac
}
ask::sudo() {
	sudo -v
}
debug() {
	[[ $STD_DEBUG != true ]] && return 0
	trap 'STD_DEBUG_CMD="$BASH_COMMAND" STD_DEBUG_FUNC=(${BASH_LINENO[@]}) STD_DEBUG_CMD_NUM="$LINENO" STD_DEBUG_PIPE=(${PIPESTATUS[@]});debug::trap' DEBUG
}
debug::trap() {
	if [[ -z $STD_DEBUG_INIT ]]; then
		declare -g STD_DEBUG_INIT
		STD_DEBUG_INIT=${EPOCHREALTIME//./}
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug 0.000000] " "[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
		local f
		local i=1
		for f in ${STD_DEBUG_FUNC[@]-1}; do
			[[ $f = 0 ]] && break
			printf "\033[1;91m%s\033[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
			((i++))
		done
		printf "\033[0m\n"
		return
	fi
	local STD_DEBUG_ADJUSTED STD_DEBUG_DOT
	STD_DEBUG_ADJUSTED=$((${EPOCHREALTIME//./}-STD_DEBUG_INIT))
	case ${#STD_DEBUG_ADJUSTED} in
		1) STD_DEBUG_ADJUSTED=00000${STD_DEBUG_ADJUSTED//$'\n'};;
		2) STD_DEBUG_ADJUSTED=0000${STD_DEBUG_ADJUSTED//$'\n'};;
		3) STD_DEBUG_ADJUSTED=000${STD_DEBUG_ADJUSTED//$'\n'};;
		4) STD_DEBUG_ADJUSTED=00${STD_DEBUG_ADJUSTED//$'\n'};;
		5) STD_DEBUG_ADJUSTED=0${STD_DEBUG_ADJUSTED//$'\n'};;
	esac
	STD_DEBUG_DOT=$((${#STD_DEBUG_ADJUSTED}-6))
	if [[ $STD_DEBUG_DOT -eq 0 ]]; then
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug 0.${STD_DEBUG_ADJUSTED}] " "[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
	else
		printf "\r\e[2K\033[1;90m%s\033[1;93m%s\033[0m%s\033[1;93m%s" \
			"[debug ${STD_DEBUG_ADJUSTED:0:${STD_DEBUG_DOT}}.${STD_DEBUG_ADJUSTED:${STD_DEBUG_DOT}}] " \
			"[ \$_ ] " "${STD_DEBUG_CMD_NUM}: $STD_DEBUG_CMD " "-> "
	fi
	local f
	local i=1
	for f in ${STD_DEBUG_FUNC[@]-1}; do
		[[ $f = 0 ]] && break
		printf "\033[1;91m%s\033[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
		((i++))
	done
	printf "\033[0m\n"
}
log::ok() {
	printf "\r\e[2K"
	printf "\r\e[1;32m[  OK  ]\e[0m %s\n" "$@"
}
log::info() {
	printf "\r\e[2K"
	printf "\r\e[1;37m[ INFO ]\e[0m %s\n" "$@"
}
log::warn() {
	printf "\r\e[2K"
	printf "\r\e[1;33m[ WARN ]\e[0m %s\n" "$@"
}
log::fail() {
	printf "\r\e[2K"
	printf "\r\e[1;31m[ FAIL ]\e[0m %s\n" "$@"
}
log::danger() {
	printf "\r\e[2K"
	printf "\r\e[1;31m[DANGER]\e[0m %s\n" "$@"
}
log::tab() {
	printf "\r\e[2K"
	printf "\r\e[0m         %s\n" "$@"
}
log::prog() {
	printf "\r\e[2K"
	printf "\r\e[1;37m[ \e[0m....\e[1;37m ]\e[0m %s " "$@"
}
log::debug() {
	[[ $STD_LOG_DEBUG != true ]] && return 0
	if [[ $STD_LOG_DEBUG_LAST_FUNC != "${FUNCNAME[1]}" ]]; then
		declare -g STD_LOG_DEBUG_LAST_FUNC="${FUNCNAME[1]}"
		case "$STD_LOG_DEBUG_FUNC_COLOR" in
			"\e[1;91m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;92m";;
			"\e[1;92m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;93m";;
			"\e[1;93m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;94m";;
			"\e[1;94m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;95m";;
			"\e[1;95m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;96m";;
			"\e[1;96m") STD_LOG_DEBUG_FUNC_COLOR="\e[1;97m";;
			*) STD_LOG_DEBUG_FUNC_COLOR="\e[1;91m";;
		esac
	fi
	if [[ -z $STD_LOG_DEBUG_INIT ]]; then
		declare -g STD_LOG_DEBUG_INIT
		STD_LOG_DEBUG_INIT=${EPOCHREALTIME//[!0-9]/}
		printf "\r\e[2K\e[1;90m%s${STD_LOG_DEBUG_FUNC_COLOR}%s\e[0m%s" "[log::debug 0.000000] " "${FUNCNAME[1]}() " "$* "
		if [[ $STD_LOG_DEBUG_VERBOSE = true ]]; then
			printf "\e[1;93m%s" "-> "
			local f i
			i=1
			for f in ${BASH_LINENO[@]}; do
				[[ $f = 0 ]] && break
				printf "\e[1;91m%s\e[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
				((i++))
			done
		fi
		printf "\e[0m\n"
		return
	fi
	local STD_LOG_DEBUG_ADJUSTED STD_LOG_DEBUG_DOT
	STD_LOG_DEBUG_ADJUSTED=$((${EPOCHREALTIME//[!0-9]/}-STD_LOG_DEBUG_INIT))
	case ${#STD_LOG_DEBUG_ADJUSTED} in
		1) STD_LOG_DEBUG_ADJUSTED=00000${STD_LOG_DEBUG_ADJUSTED};;
		2) STD_LOG_DEBUG_ADJUSTED=0000${STD_LOG_DEBUG_ADJUSTED};;
		3) STD_LOG_DEBUG_ADJUSTED=000${STD_LOG_DEBUG_ADJUSTED};;
		4) STD_LOG_DEBUG_ADJUSTED=00${STD_LOG_DEBUG_ADJUSTED};;
		5) STD_LOG_DEBUG_ADJUSTED=0${STD_LOG_DEBUG_ADJUSTED};;
	esac
	STD_LOG_DEBUG_DOT=$((${#STD_LOG_DEBUG_ADJUSTED}-6))
	if [[ $STD_LOG_DEBUG_DOT -eq 0 ]]; then
		printf "\r\e[2K\e[1;90m%s${STD_LOG_DEBUG_FUNC_COLOR}%s\e[0m%s" "[log::debug 0.${STD_LOG_DEBUG_ADJUSTED}] " "${FUNCNAME[1]}() " "$* "
	else
		printf "\r\e[2K\e[1;90m%s${STD_LOG_DEBUG_FUNC_COLOR}%s\e[0m%s" \
			"[log::debug ${STD_LOG_DEBUG_ADJUSTED:0:${STD_LOG_DEBUG_DOT}}.${STD_LOG_DEBUG_ADJUSTED:${STD_LOG_DEBUG_DOT}}] " "${FUNCNAME[1]}() " "$* "
	fi
	if [[ $STD_LOG_DEBUG_VERBOSE = true ]]; then
		printf "\e[1;93m%s" "-> "
		local f i
		i=1
		for f in ${BASH_LINENO[@]}; do
			[[ $f = 0 ]] && break
			printf "\e[1;91m%s\e[1;92m%s" "${f}: " "${FUNCNAME[${i}]}() "
			((i++))
		done
	fi
	printf "\e[0m\n"
}
readonly BLACK="\e[0;30m"
readonly RED="\e[0;31m"
readonly GREEN="\e[0;32m"
readonly YELLOW="\e[0;33m"
readonly BLUE="\e[0;34m"
readonly PURPLE="\e[0;35m"
readonly CYAN="\e[0;36m"
readonly WHITE="\e[0;37m"
readonly BBLACK="\e[1;90m"
readonly BRED="\e[1;91m"
readonly BGREEN="\e[1;92m"
readonly BYELLOW="\e[1;93m"
readonly BBLUE="\e[1;94m"
readonly BPURPLE="\e[1;95m"
readonly BCYAN="\e[1;96m"
readonly BWHITE="\e[1;97m"
readonly UBLACK="\e[4;30m"
readonly URED="\e[4;31m"
readonly UGREEN="\e[4;32m"
readonly UYELLOW="\e[4;33m"
readonly UBLUE="\e[4;34m"
readonly UPURPLE="\e[4;35m"
readonly UCYAN="\e[4;36m"
readonly UWHITE="\e[4;37m"
readonly IBLACK="\e[0;90m"
readonly IRED="\e[0;91m"
readonly IGREEN="\e[0;92m"
readonly IYELLOW="\e[0;93m"
readonly IBLUE="\e[0;94m"
readonly IPURPLE="\e[0;95m"
readonly ICYAN="\e[0;96m"
readonly IWHITE="\e[0;97m"
readonly BOLD="\e[1m"
readonly ITALIC="\e[3m"
readonly OFF="\e[0m"
___BEGIN___ERROR___TRACE___() {
	POSIXLY_CORRECT= || exit 8
	\unset -f true false trap set return exit printf unset local return read unalias mapfile kill builtin wait || exit 9
	\unalias -a || exit 10
	unset -v POSIXLY_CORRECT || exit 11
	unset -f : || exit 1
	trap 'STD_TRACE_CMD="$BASH_COMMAND" STD_TRACE_FUNC=(${BASH_LINENO[@]}) STD_TRACE_CMD_NUM="$LINENO" STD_TRACE_PIPE=(${PIPESTATUS[@]}); ___ENDOF___ERROR___TRACE___ > /dev/tty || exit 100' ERR || exit 12
	unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 13
	set -E -e -o pipefail || exit 14
	return 0
}
___ENDOF___ERROR___TRACE___() {
	POSIXLY_CORRECT= || exit 15
	\unset -f true false trap set return exit printf unset local return read unalias mapfile kill builtin wait || exit 16
	\unalias -a || exit 17
	unset -v POSIXLY_CORRECT || exit 18
	unset -f : || exit 1
	if [[ -z $STD_TRACE_PIPE ]]; then
		POSIXLY_CORRECT= || exit 19
		\unset -f trap set return exit return || exit 20
		\unalias -a || exit 21
		unset POSIXLY_CORRECT || exit 22
		unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 23
		set +E +eo pipefail || exit 24
		trap - ERR || exit 25
		return 0
	fi
	printf "\e[1;91m%s\n" "========  BEGIN ERROR TRACE  ========"
	printf "\e[1;95m%s\e[0m%s\n" "[bash] " "$BASH_VERSION"
	printf "\e[1;96m%s\e[0m%s\n" "[unix] " "$EPOCHSECONDS"
	printf "\e[1;91m%s" "[code] "
	for i in "${STD_TRACE_PIPE[@]}"; do
		printf "\e[0m%s" "$i"
	done
	printf "\n\e[1;97m%s\e[0m%s\n" "[file] " "${BASH_SOURCE[-1]}"
	printf "\e[1;94m%s\e[0m%s\n" "[ wd ] " "$PWD"
	printf "\e[1;93m%s\e[0m%s\n" "[ \$_ ] " "${STD_TRACE_CMD_NUM}: $STD_TRACE_CMD"
	local f
	local i=1
	for f in "${STD_TRACE_FUNC[@]}"; do
		[[ $f = 0 ]] && break
		printf "\e[1;92m%s\e[0m%s\n" "[func] " "${f}: ${FUNCNAME[${i}]}()"
		((i++))
	done
	local STD_TRACE_LINE_ARRAY
	local STD_ORIGINAL_LINE="$STD_TRACE_CMD_NUM"
	if [[ $STD_TRACE_CMD_NUM -lt 5 ]]; then
		local STD_TRACE_CMD_NUM=1
		mapfile -n 9 STD_TRACE_LINE_ARRAY < "$0"
	else
		local STD_TRACE_CMD_NUM=$((STD_TRACE_CMD_NUM-4))
		mapfile -s $((STD_TRACE_CMD_NUM-1)) -n 9 STD_TRACE_LINE_ARRAY < "$0"
	fi
	for i in {0..8}; do
		[[ ${STD_TRACE_LINE_ARRAY[$i]} ]] || break
	  local STD_TRACE_SPACING="    "
		if [[ $STD_TRACE_CMD_NUM = "$STD_ORIGINAL_LINE" ]]; then
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;97m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				2) printf "\e[1;97m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				3) printf "\e[1;97m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				4) printf "\e[1;97m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				5) printf "\e[1;97m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				*) printf "\e[1;97m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
			esac
		else
			case ${#STD_TRACE_CMD_NUM} in
				1) printf "\e[1;90m%s" "     $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				2) printf "\e[1;90m%s" "    $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				3) printf "\e[1;90m%s" "   $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				4) printf "\e[1;90m%s" "  $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				5) printf "\e[1;90m%s" " $STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
				*) printf "\e[1;90m%s" "$STD_TRACE_CMD_NUM ${STD_TRACE_LINE_ARRAY[${i}]//$'\t'/${STD_TRACE_SPACING}}" ;;
			esac
		fi
		((STD_TRACE_CMD_NUM++))
	done
	[[ $STD_TRACE_RETURN ]] && printf "\e[38;5;196m%s\e[0;1m%s\e[0m\n" "[STD_TRACE_RETURN]" " $STD_TRACE_RETURN"
	printf "\e[1;91m%s\e[0m\n" "========  ENDOF ERROR TRACE  ========"
	unset -v STD_TRACE_CMD STD_TRACE_FUNC_NUM STD_TRACE_CMD_NUM STD_TRACE_PIPE || exit 26
	set +E +eo pipefail || exit 27
	trap - ERR || exit 28
	if [[ $BASH_SUBSHELL != 0 ]]; then
		printf "\e[1;93m%s\e[0m\n" "======  SUB-SHELLS TERMINATED  ======"
	fi
	builtin kill -s TERM 0
	exit 99
	printf "\e[1;97m%s\e[0m\n" "=KILL/EXIT FAIL, BEGIN INFINITE LOOP="
	while :; do read -s -r; done
	while true; do read -s -r; done
	while true; do false; done
	while :; do :; done
}
declare -frg ask::yes
declare -frg ask::no
declare -frg ask::sudo
declare -frg debug
declare -frg debug::trap
declare -frg log::ok
declare -frg log::info
declare -frg log::warn
declare -frg log::fail
declare -frg log::danger
declare -frg log::tab
declare -frg log::prog
declare -frg log::debug
declare -frg ___BEGIN___ERROR___TRACE___
declare -frg ___ENDOF___ERROR___TRACE___
trap - ERR || exit 117
set +eo pipefail || exit 118

#-------------------------------------------------------------------------------- BEGIN MAIN
hbc() {
___BEGIN___ERROR___TRACE___
debug
if [[ $* = *"-h"* || $* = *"--help"* ]]; then
printf "${BWHITE}%s${OFF}%s${BPURPLE}%s${BYELLOW}%s\n\n" "USAGE: " "hbc " "--OPTION " "<ARGUMENT>"
printf "${BPURPLE}%s${OFF}%s${BPURPLE}%s${BYELLOW}%s${OFF}%s\n" \
"    -a" " |" " --add" "     <text file>" "          add a text file (like a license) on top of output, default: [LICENSE]" \
"    -c" " |" " --config" "  <hbc config file>" "    specify hbc config to use, default: [\$PWD/hbc.conf] or [/etc/hbc.conf]"
printf "${BPURPLE}%s${OFF}%s${BPURPLE}%s${OFF}%s\n" \
"    -d" " |" " --delete" "                       overwrite output file if it already exists"
"    -f" " |" " --full" "                      "  "fully clean the output, including [main.sh]"
printf "${BPURPLE}%s${OFF}%s${BPURPLE}%s${BYELLOW}%s${OFF}%s\n" \
"    -i" " |" " --ignore" "  <codes> or <ALL>" "     ignore shellcheck codes or disable shellcheck: [-i SC2154,SC2155] or [-i ALL]" \
"    -l" " |" " --library" " <library directory>" "  specify where to look for lib code, default: [/usr/local/include]" \
"    -m" " |" " --main" "    <main script name>" "   specify main script name, default: [main.sh]"
printf "${BPURPLE}%s${OFF}%s${BPURPLE}%s${OFF}%s\n" \
"    -h" " |" " --help" "                         print this help message and exit unsuccessfully"
printf "${BPURPLE}%s${OFF}%s${BPURPLE}%s${BYELLOW}%s${OFF}%s\n" \
"    -o" " |" " --output" "  <output name>" "        specify output filename, default: [\$FOLDER_NAME.sh]"
printf "${BPURPLE}%s${OFF}%s${BPURPLE}%s${OFF}%s\n" \
"    -q" " |" " --quiet" "                        suppress hbc compile-time output (exit codes stay)" \
"    -r" " |" " --run" "                          run output file if hbc successfully compiles"
printf "${BPURPLE}%s${OFF}%s${BPURPLE}%s${BYELLOW}%s${OFF}%s\n" \
"    -s" " |" " --source" "  <source directory>" "   specify where to look for src code, default: [src]"
printf "${BPURPLE}%s${OFF}%s${BPURPLE}%s${OFF}%s\n" \
"    -t" " |" " --test" "                         --run & --quiet the output from memory, no file made" \
"    -v" " |" " --version" "                      print this hbc's time of compile and exit unsuccessfully"
printf "${OFF}%s\n" \
	"" \
	"hbc - hinto's bash compiler" \
	"Full documentation <https://github.com/hinto-janaiyo/hbc>" \
	"Copyright (c) 2022 hinto-janaiyo <https://github.com/hinto-janaiyo>"
exit 2
elif [[ $* = *"-v"* || $* = *"--version"* ]]; then
	printf "%s\n" "2022 July 26 - e35ca7aadd540b201dbd2e20c38af29b12bfcd9d"
	exit 3
fi
unset -v ADD OPTIONS CONFIG FULL LICENSE DELETE IGNORE LIBRARY MAIN OUTPUT QUIET RUN SOURCE TEST
hbc_parse_config() {
	local i IFS=$'\n' OPTIONS || return 1
	mapfile OPTIONS < $1 || return 2
	for i in ${OPTIONS[@]}; do
	    [[ $i =~ ^ADD=[[:alnum:]./_-]*$ ]]                   && declare -g LICENSE="${i/*=/}"
	    [[ $i =~ ^DELETE=true[[:space:]]*$ ]]                && declare -g DELETE=true
		[[ $i =~ ^FULL=true[[:space:]]*$ ]]                  && declare -g FULL=true
		[[ $i =~ ^IGNORE=SC.*$ ]]                            && declare -g IGNORE=${i/*=/}
		[[ $i =~ ^LIBRARY=[[:alnum:]./_-]*$ ]]               && declare -g LIBRARY="${i/*=/}"
		[[ $i =~ ^MAIN=[[:alnum:]./_-]*$ ]]                  && declare -g MAIN="${i/*=/}"
		[[ $i =~ ^OUTPUT=[[:alnum:]./_-]*$ ]]                && declare -g OUTPUT="${i/*=/}"
	    [[ $i =~ ^QUIET=true[[:space:]]*$ ]]                 && declare -g QUIET=true
	    [[ $i =~ ^RUN=true[[:space:]]*$ ]]                   && declare -g RUN=true
		[[ $i =~ ^SOURCE=[[:alnum:]./_-]*$ ]]                && declare -g SOURCE="${i/*=/}"
	    [[ $i =~ ^TEST=true[[:space:]]*$ ]]                  && declare -g TEST=true
	    [[ $i =~ ^STD_LOG_DEBUG=true[[:space:]]*$ ]]         && declare -g STD_LOG_DEBUG=true
	    [[ $i =~ ^STD_LOG_DEBUG_VERBOSE=true[[:space:]]*$ ]] && declare -g STD_LOG_DEBUG_VERBOSE=true
	done
	log::debug "=== hbc_parse_config ==="
	log::debug "ADD     | $LICENSE"
	log::debug "CONFIG  | $CONFIG"
	log::debug "DELETE  | $DELETE"
	log::debug "FULL    | $FULL"
	log::debug "IGNORE  | $IGNORE"
	log::debug "LIBRARY | $LIBRARY"
	log::debug "MAIN    | $MAIN"
	log::debug "OUTPUT  | $OUTPUT"
	log::debug "QUIET   | $QUIET"
	log::debug "RUN     | $RUN"
	log::debug "SOURCE  | $SOURCE"
	log::debug "TEST    | $TEST"
	return 0
}
local i CONFIG_FLAG_SET
for i in $@ " "; do
	if [[ $i = "-c" || $i = "--config" ]]; then
		CONFIG_FLAG_SET=true
	elif [[ $CONFIG_FLAG_SET ]]; then
		local CONFIG="$i"
		if [[ -z $CONFIG || $CONFIG = " " ]]; then
			log::fail "hbc: no arg after --config"
			exit 1
		fi
		if hbc_parse_config "$CONFIG"; then
			break
		else
			log::fail "config: $CONFIG"
			exit 1
		fi
	fi
done
if [[ -r "$PWD/hbc.conf" && -z $CONFIG_FLAG_SET ]]; then
	local CONFIG="$PWD/hbc.conf"
	if ! hbc_parse_config "$CONFIG"; then
		log::warn "config: $CONFIG fail"
	fi
elif [[ -r /etc/hbc.conf && -z $CONFIG_FLAG_SET ]]; then
	local CONFIG="/etc/hbc.conf"
	if ! hbc_parse_config "$CONFIG"; then
		log::warn "config: $CONFIG fail"
	fi
fi
while [[ $# != 0 ]]; do
case $1 in
	-a | --add)
		shift
		if [[ -z $1 ]]; then
			log::fail "hbc: no arg after --add"
			exit 1
		fi
		LICENSE="$1"; shift;;
	-c | --config) shift; shift;;
	-d | --delete) local DELETE=true; shift;;
	-f | --full)   local FULL=true; shift;;
	-i | --ignore)
		shift
		if [[ -z $1 ]]; then
			log::fail "hbc: no arg after --ignore"
			exit 1
		fi
		local IGNORE="${IGNORE},$1"; shift;;
	-l | --library)
		shift
		if [[ -z $1 ]]; then
			log::fail "hbc: no arg after --library"
			exit 1
		fi
		local LIBRARY="$1"; shift;;
	-m | --main)
		shift
		if [[ -z $1 ]]; then
			log::fail "hbc: no arg after --main"
			exit 1
		fi
		local MAIN="$1"; shift;;
	-o | --output)
		shift
		if [[ -z $1 ]]; then
			log::fail "hbc: no arg after --output"
			exit 1
		fi
		OUTPUT="$1"; shift;;
	-q | --quiet) QUIET=true; shift;;
	-r | --run) RUN=true; shift;;
	-s | --source)
		shift
		if [[ -z $1 ]]; then
			log::fail "hbc: no arg after --source"
			exit 1
		fi
		SOURCE="$1"; shift;;
	-t | --test) TEST=true; shift;;
	*) log::fail "hbc: invalid option: $1"; exit 1;;
esac
done
[[ $TEST = true ]] && RUN=true QUIET=true
___ENDOF___ERROR___TRACE___
[[ $CONFIG && -z $QUIET ]] && log::info "config: $CONFIG"
[[ -z $LICENSE ]] && local LICENSE="LICENSE"
if [[ -r $LICENSE ]]; then
	[[ -z $QUIET ]] && log::info "add: $LICENSE"
else
	log::warn "add: $LICENSE not found"
	unset -v LICENSE
fi
[[ -z $SOURCE ]] && local SOURCE="src"
if [[ ! -d $SOURCE ]]; then
	log::warn "src: $SOURCE not found"
else
	[[ -z $QUIET ]] && log::info "src: $SOURCE"
fi
[[ -z $MAIN ]] && local MAIN="main.sh"
if [[ ! -r $MAIN ]]; then
	log::fail "main: $MAIN not found"
	exit 1
else
	[[ -z $QUIET ]] && log::info "main: $MAIN"
fi
local EXISTS_LIB=true
local SRC_FILES
local SRC_FILE_NAMES
SRC_FILES=$(find $SOURCE -regex ".*\.sh\|.*\.bash" 2>/dev/null | sort)
if ! grep -m1 "^#include <.*>$" "$MAIN" &>/dev/null; then
	EXISTS_LIB=false
	if [[ -z $SRC_FILES ]]; then
		log::fail "both [lib/src] are missing" "no reason to use hbc"
		exit 1
	fi
fi
local DIRECTORY_NAME
DIRECTORY_NAME="$(basename "$PWD")"
if [[ $DIRECTORY_NAME = hbc && -z $OUTPUT ]]; then
	OUTPUT="hbc"
elif [[ -z $OUTPUT ]]; then
	OUTPUT="${DIRECTORY_NAME}.sh"
fi
case $DIRECTORY_NAME in
	*lib|*lib.sh|lib*|*Lib|*Lib.sh|Lib*|*LIB|*LIB.sh|LIB*)
		DIRECTORY_IS_LIB=true
		;;
esac
if [[ $MAIN != [A-Za-z0-9_/~$]* ]]; then
	log::fail "hbc: \$MAIN contains weird characters; only [A-Za-z0-9_/~$] is supported"
	exit 1
elif [[ $OUTPUT != [A-Za-z0-9_/]* ]]; then
	log::fail "hbc: \$OUTPUT contains weird characters; only [A-Za-z0-9_/~$] is supported"
	exit 1
fi
log::debug "=== post --option debug ==="
log::debug "ADD     | $LICENSE"
log::debug "CONFIG  | $CONFIG"
log::debug "DELETE  | $DELETE"
log::debug "IGNORE  | $IGNORE"
log::debug "LIBRARY | $LIBRARY"
log::debug "MAIN    | $MAIN"
log::debug "OUTPUT  | $OUTPUT"
log::debug "QUIET   | $QUIET"
log::debug "RUN     | $RUN"
log::debug "SOURCE  | $SOURCE"
log::debug "TEST    | $TEST"
if [[ $DIRECTORY_IS_LIB = true ]]; then
	log::warn "library detected, not adding safety headers!"
fi
if [[ -e $OUTPUT && $DELETE != true && $TEST != true ]]; then
	log::warn "$OUTPUT already exists"
	printf "%s" "         overwrite? (y/N) "
	ask::no && exit 2
fi
[[ $QUIET = true ]] && exec 3>&1 &>/dev/null
___BEGIN___ERROR___TRACE___
local HEADER_SAFETY="#-------------------------------------------------------------------------------- BEGIN SAFETY"
local HEADER_LIB="#-------------------------------------------------------------------------------- BEGIN LIB"
local HEADER_SRC="#-------------------------------------------------------------------------------- BEGIN SRC"
local HEADER_MAIN="#-------------------------------------------------------------------------------- BEGIN MAIN"
local ENDOF_MAIN="#-------------------------------------------------------------------------------- ENDOF MAIN"
local DIRECTORY_GIT
DIRECTORY_GIT=$(git rev-parse --short HEAD 2>/dev/null) || unset DIRECTORY_GIT
local VERSION_HBC
VERSION_HBC=$(grep -m1 "^#git <hbc/.*>$" "$0" | grep -o "\/.*>" | tr -d '/>')
local LIB_GIT
[[ -z $LIBRARY ]] && LIBRARY="/usr/local/include"
declare -g TMP_DIR
local TMP_HEADER
local TMP_SAFETY
local TMP_LIB
local TMP_SRC
local TMP_MAIN
local TMP_SCRATCH
local VAR_SCRATCH
local EXISTS_TMP
if EXISTS_TMP=$(find /tmp/hbc.* -type d 2>/dev/null); then
	printf "${BWHITE}%s${OFF}\n" "cleaning [tmp]"
	local i
	for i in $EXISTS_TMP; do
		log::tab "$i"
		rm -rf "$i"
	done
fi
TMP_DIR="$(mktemp -d /tmp/hbc.XXXXXXXXXX)"
TMP_HEADER="$(mktemp "$TMP_DIR"/header.XXXXXXXXX)"
TMP_SAFETY="$(mktemp "$TMP_DIR"/safety.XXXXXXXXX)"
TMP_LIB="$(mktemp "$TMP_DIR"/lib.XXXXXXXXXX)"
TMP_SRC="$(mktemp "$TMP_DIR"/src.XXXXXXXXXX)"
TMP_MAIN="$(mktemp "$TMP_DIR"/main.XXXXXXXXXX)"
TMP_SCRATCH="$(mktemp "$TMP_DIR"/scratch.XXXXXXXXXX)"
if [[ $TEST = true ]]; then
	local TMP_TEST
	TMP_TEST="$(mktemp "$TMP_DIR"/test.XXXXXXXXXX)"
	OUTPUT="$TMP_TEST"
fi
local SAFETY_HEADER
SAFETY_HEADER=$(cat << 'EOM'
POSIXLY_CORRECT= || exit 90
\unset -f alias bg bind break builtin caller cd command compgen complete compopt continue declare dirs disown echo enable eval exec exit export false fc fg getopts hash help history jobs kill let local logout mapfile popd printf pushd pwd read readarray readonly return set shift shopt source suspend test times trap true type typeset ulimit umask unalias unset wait || exit 91
\unset -f arch base64 basename cat chcon chgrp chmod chown chroot cksum comm cp csplit cut date dd df dir dircolors dirname du echo env expand expr factor false fmt fold groups head hostid hostname id install join kill link ln logname ls md5sum mkdir mkfifo mknod mktemp mv nice nl nohup nproc numfmt od paste pathchk pinky pr printenv printf ptx pwd readlink realpath rm rmdir runcon seq shred shuf sleep sort split stat stdbuf stty sum tac tail tee test timeout touch tr true truncate tsort tty uname unexpand uniq unlink uptime users vdir wc who whoami yes || exit 92
\unalias -a || exit 93
unset POSIXLY_CORRECT || exit 94
unset -f . : [ || exit 95
set -eo pipefail || exit 96
EOM
)
SAFETY_LIB=$(cat << 'EOM'
trap 'printf "%s\n" "@@@@@@ LIB PANIC @@@@@@" "[line] ${LINENO}" "[file] $0" "[code] $?";set +eo pipefail;trap - ERR;while :;do read;done;exit 112' ERR || exit 112
EOM
)
local SAFETY_SRC
SAFETY_SRC=$(cat << 'EOM'
trap 'printf "%s\n" "@@@@@@ SRC PANIC @@@@@@" "[line] ${LINENO}" "[file] $0" "[code] $?";set +eo pipefail;trap - ERR;while :;do read;done;exit 115' ERR || exit 115
EOM
)
local SAFETY_END
SAFETY_END=$(cat << 'EOM'
trap - ERR || exit 117
set +eo pipefail || exit 118
EOM
)
printf "${BBLUE}%s${OFF}\n" "compiling [header] ***************"
log::tab "#!/usr/bin/env bash"
echo "#!/usr/bin/env bash" > "$TMP_HEADER"
if [[ $LICENSE ]]; then
	log::tab "add: $LICENSE"
	echo "#" >> "$TMP_HEADER"
	cat "$LICENSE" >> "$TMP_HEADER"
	echo  >> "$TMP_HEADER"
fi
if [[ $DIRECTORY_GIT ]]; then
	log::tab "git: $DIRECTORY_GIT"
	if [[ $DIRECTORY_NAME = hbc ]]; then
		echo "#git <hbc/${DIRECTORY_GIT}>" >> "$TMP_HEADER"
	else
		echo "#git <${OUTPUT}/${DIRECTORY_GIT}>" >> "$TMP_HEADER"
	fi
else
	log::warn "git: no hash found"
fi
log::tab "nix: $EPOCHSECONDS"
echo "#nix <$EPOCHSECONDS>" >> "$TMP_HEADER"
log::tab "hbc: $VERSION_HBC"
echo "#hbc <$VERSION_HBC>" >> "$TMP_HEADER"
if [[ $DIRECTORY_IS_LIB != true ]]; then
	printf "${BRED}%s${OFF}\n" "creating [safety] ****************"
	log::tab "<safety>"
	echo "$SAFETY_HEADER" >> "$TMP_SAFETY"
fi
if [[ $EXISTS_LIB = true && $DIRECTORY_IS_LIB != true ]]; then
	printf "${BPURPLE}%s${OFF}\n" "compiling [lib] ******************"
	local i
	for i in $(grep "^#include <.*>$" "$MAIN" | cut -d ' ' -f2 | tr -d '<>' | sort); do
		if [[ $i = *.bash || $i = *.sh && -f "${LIBRARY}/${i}" ]]; then
			sed "/^#\|^[[:space:]]#/d" "$LIBRARY/$i" >> "$TMP_LIB"
			if LIB_GIT=$(grep -m1 "^#git <.*>$" "$LIBRARY/$i" | cut -d ' ' -f2); then
				log::tab "$LIB_GIT"
				echo "#lib $LIB_GIT" >> "$TMP_HEADER"
			else
				log::warn "<lib missing #git>"
				echo "#lib <UNKNOWN>" >> "$TMP_HEADER"
			fi
		else
			log::fail "${LIBRARY}/${i} not *.sh || ${LIBRARY}/${i} not found"
			exit 1
		fi
	done
fi
if [[ $SRC_FILES ]]; then
	printf "${BCYAN}%s${OFF}\n" "compiling [src] ******************"
	for i in $SRC_FILES; do
		log::tab "<${i/src\//}>"
		sed "/^#\|^[[:space:]]#/d" "$i" >> "$TMP_SRC"
		echo "#src <${i/src\//}>" >> "$TMP_HEADER"
	done
fi
local EXISTS_MAIN
EXISTS_MAIN=$(sed -e "/^#include <.*>$/d" -e '/./,$!d' "$MAIN")
if [[ $EXISTS_MAIN ]]; then
	printf "${BWHITE}%s${OFF}\n" "compiling [main] *****************"
	log::tab "$MAIN"
	echo "$EXISTS_MAIN" > "$TMP_MAIN"
fi
printf "${BYELLOW}%s${OFF}\n" "cleaning *************************"
log::tab "creating scratch"
echo "$SAFETY_HEADER" > "$TMP_SCRATCH"
echo "$SAFETY_LIB" >> "$TMP_SCRATCH"
echo "$SAFETY_SRC" >> "$TMP_SCRATCH"
echo "$SAFETY_END" >> "$TMP_SCRATCH"
if [[ $EXISTS_LIB = true ]]; then
	local LINES_LIB
	LINES_LIB[0]=$(wc -l "$TMP_LIB" | cut -d ' ' -f1)
	sed -i -e '/#!\/usr\/bin\/env bash$/d' \
		-i -e '/#!\/usr\/bin\/bash$/d' \
		-i -e '/#!\/bin\/bash$/d' \
		-i -e '/^$/d' \
		-i -e '/^#/d' \
		-i -e '/^[[:space:]]*#/d' "$TMP_LIB"
	LINES_LIB[1]=$(wc -l "$TMP_LIB" | cut -d ' ' -f1)
	log::tab "[lib] sed  removed: $((LINES_LIB[0] - LINES_LIB[1]))"
	if VAR_SCRATCH="$(grep -vxFf "$TMP_SCRATCH" "$TMP_LIB")"; then
		LINES_LIB[2]=$(echo "$VAR_SCRATCH" | wc -l)
		echo "$VAR_SCRATCH" > "$TMP_LIB"
		log::tab "[lib] grep removed: $((LINES_LIB[1] - LINES_LIB[2]))"
	fi
	log::tab "[lib] ${LINES_LIB[0]} -> ${LINES_LIB[2]}"
fi
if [[ $SRC_FILES ]]; then
	local LINES_SRC
	LINES_SRC[0]=$(wc -l "$TMP_SRC" | cut -d ' ' -f1)
	sed -i -e '/#!\/usr\/bin\/env bash$/d' \
		-i -e '/#!\/usr\/bin\/bash$/d' \
		-i -e '/#!\/bin\/bash$/d' \
		-i -e '/^$/d' "$TMP_SRC" \
		-i -e '/^#/d' \
		-i -e '/^[[:space:]]*#/d' "$TMP_SRC"
	LINES_SRC[1]=$(wc -l "$TMP_SRC" | cut -d ' ' -f1)
	log::tab "[src] sed  removed: $((LINES_SRC[0] - LINES_SRC[1]))"
	if VAR_SCRATCH="$(grep -vxFf "$TMP_SCRATCH" "$TMP_SRC")"; then
		LINES_SRC[2]=$(echo "$VAR_SCRATCH" | wc -l)
		echo "$VAR_SCRATCH" > "$TMP_SRC"
		log::tab "[src] grep removed: $((LINES_SRC[1] - LINES_SRC[2]))"
	fi
	log::tab "[src] ${LINES_SRC[0]} -> ${LINES_SRC[2]}"
fi
if [[ $FULL = true ]]; then
	local LINES_MAIN
	LINES_MAIN[0]=$(wc -l "$TMP_MAIN" | cut -d ' ' -f1)
	sed -i -e '/#!\/usr\/bin\/env bash$/d' \
		-i -e '/#!\/usr\/bin\/bash$/d' \
		-i -e '/#!\/bin\/bash$/d' \
		-i -e '/^$/d' "$TMP_MAIN" \
		-i -e '/^#/d' \
		-i -e '/^[[:space:]]*#/d' "$TMP_MAIN"
	LINES_MAIN[1]=$(wc -l "$TMP_MAIN" | cut -d ' ' -f1)
	log::tab "[main] sed removed: $((LINES_MAIN[0] - LINES_MAIN[1]))"
	log::tab "[main] ${LINES_MAIN[0]} -> ${LINES_MAIN[1]}"
fi
printf "${BGREEN}%s${OFF}\n" "linking  *************************"
printf "%s" "" > "$OUTPUT"
log::tab "[header] ---------> line $(wc -l "$OUTPUT" | cut -f1 -d ' ')"
cat "$TMP_HEADER" > "$OUTPUT"
if [[ $DIRECTORY_IS_LIB != true ]]; then
	echo >> "$OUTPUT"
	log::tab "[safety::header] -> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	echo "$HEADER_SAFETY" >> "$OUTPUT"
	log::tab "[safety] ---------> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	cat "$TMP_SAFETY" >> "$OUTPUT"
fi
if [[ $EXISTS_LIB = true && $DIRECTORY_IS_LIB != true ]]; then
	echo >> "$OUTPUT"
	log::tab "[lib::header] ----> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	echo "$HEADER_LIB" >> "$OUTPUT"
	log::tab "[lib::safety] ----> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	echo "$SAFETY_LIB" >> "$OUTPUT"
	log::tab "[lib] ------------> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	cat "$TMP_LIB" >> "$OUTPUT"
	log::tab "[lib::declare] ---> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	local FUNCTIONS_LIB
	if FUNCTIONS_LIB=($(grep -ho "^[0-9A-Za-z.:_-]\+(){\|^[0-9A-Za-z.:_-]\+()[[:blank:]]\+{" "$TMP_LIB" | tr -d '(){ ')); then
		if [[ -z ${FUNCTIONS_LIB[0]} ]]; then
			log::fail "no functions found"
			exit 3
		fi
		local d
		for d in ${FUNCTIONS_LIB[@]}; do
			echo "declare -frg $d" >> "$OUTPUT"
		done
	fi
fi
if [[ $SRC_FILES ]]; then
	echo >> "$OUTPUT"
	log::tab "[src::header] ----> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	echo "$HEADER_SRC" >> "$OUTPUT"
	if [[ $DIRECTORY_IS_LIB != true ]]; then
		log::tab "[src::safety] ----> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
		echo "$SAFETY_SRC" >> "$OUTPUT"
	fi
	log::tab "[src] ------------> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	cat "$TMP_SRC" >> "$OUTPUT"
	if [[ $DIRECTORY_IS_LIB != true ]]; then
		log::tab "[src::declare] ---> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
		local FUNCTIONS_SRC
		if FUNCTIONS_SRC=($(grep -ho "^[0-9A-Za-z.:_-]\+(){\|^[0-9A-Za-z.:_-]\+()[[:blank:]]\+{" "$TMP_SRC" | tr -d '(){ ')); then
			if [[ -z ${FUNCTIONS_SRC[0]} ]]; then
				log::fail "no functions found"
				exit 3
			fi
			local d
			for d in ${FUNCTIONS_SRC[@]}; do
				echo "declare -frg $d" >> "$OUTPUT"
			done
		fi
	fi
fi
if [[ $DIRECTORY_IS_LIB != true ]]; then
	log::tab "[safety::end] ----> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	echo "$SAFETY_END" >> "$OUTPUT"
fi
if [[ $EXISTS_MAIN ]]; then
	echo >> "$OUTPUT"
	log::tab "[main::header] ---> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	echo "$HEADER_MAIN" >> "$OUTPUT"
	log::tab "[main] -----------> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	cat "$TMP_MAIN" >> "$OUTPUT"
	log::tab "[main::endof] ----> line $(($(wc -l "$OUTPUT" | cut -f1 -d ' ')+1))"
	echo "$ENDOF_MAIN" >> "$OUTPUT"
	if [[ $DIRECTORY_NAME = hbc ]]; then
		local VERSION_LINE
		VERSION_LINE="$(printf "%s\n" "$(date -d @$EPOCHSECONDS "+%Y %B %d") - $(git rev-parse HEAD 2>/dev/null)")"
		VERSION_LINE='printf "%s\\n" '\""$VERSION_LINE"\"''
		sed -i '0,/___TEMPORARY___LINE___MEANT___FOR___REPLACEMENT___/s//'"$VERSION_LINE"'/' $OUTPUT
		log::tab "hbc version replacement"
	fi
fi
log::tab "[${OUTPUT}] total lines: $(wc -l "$OUTPUT" | cut -f1 -d ' ')"
log::info "700 permissions"
chmod 700 "${OUTPUT}"
if [[ $IGNORE = *ALL* || $IGNORE = *all* ]]; then
	log::warn "skipping shellcheck"
else
	log::info "starting shellcheck"
	if [[ $QUIET = true ]]; then
		if [[ $IGNORE ]]; then
			shellcheck "${OUTPUT}" --shell bash -e "$IGNORE" >&3
		else
			shellcheck "${OUTPUT}" --shell bash >&3
		fi
	else
		if [[ $IGNORE ]]; then
			shellcheck "${OUTPUT}" --shell bash -e "$IGNORE"
		else
			shellcheck "${OUTPUT}" --shell bash
		fi
	fi
fi
if [[ $TEST != true ]]; then
	log::info "deleting $TMP_DIR"
	rm -rf "$TMP_DIR"
fi
log::ok "$OUTPUT"
[[ $QUIET = true ]] && exec &>/dev/tty
___ENDOF___ERROR___TRACE___
}
hbc $@
if [[ $? = 0 && $RUN = true ]]; then
	if [[ $TEST = true ]]; then
		log::debug "beginning --test"
		trap 'trap - EXIT; rm -rf "$TMP_DIR"' EXIT
		bash "$OUTPUT"
		exit $?
	else
		log::debug "beginning --run"
		exec ./"$OUTPUT"
	fi
fi
log::debug "hbc done"
exit 0
#-------------------------------------------------------------------------------- ENDOF MAIN
